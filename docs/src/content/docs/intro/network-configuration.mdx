---
title:  Network Configuration
description: Learn how to configure the Synapse SDK for different networks.
sidebar: 
  order: 2
---

### RPC Endpoints

```typescript
import { RPC_URLS } from '@filoz/synapse-sdk'

// Mainnet
RPC_URLS.mainnet.websocket  // wss://wss.node.glif.io/apigw/lotus/rpc/v1
RPC_URLS.mainnet.http       // https://api.node.glif.io/rpc/v1

// Calibration Testnet
RPC_URLS.calibration.websocket  // wss://wss.calibration.node.glif.io/apigw/lotus/rpc/v1
RPC_URLS.calibration.http       // https://api.calibration.node.glif.io/rpc/v1
```

### GLIF Authorization

For higher rate limits with GLIF endpoints:

```typescript
import { Synapse } from '@filoz/synapse-sdk'

// Using GLIF authorization with private key
const synapse = await Synapse.create({
  privateKey: '0x...',
  rpcURL: 'https://api.node.glif.io/rpc/v1',
  authorization: 'Bearer YOUR_GLIF_TOKEN'
})
```

### Connection Management

#### WebSocket vs HTTP

The SDK supports both WebSocket and HTTP connections:

- **WebSocket** (recommended): Better performance for multiple operations, real-time updates, lower latency
- **HTTP**: Simpler setup, stateless, better for single operations

```typescript
// WebSocket connection (recommended)
const synapse = await Synapse.create({
  privateKey: '0x...',
  rpcURL: RPC_URLS.calibration.websocket
})

// HTTP connection
const synapse = await Synapse.create({
  privateKey: '0x...',
  rpcURL: RPC_URLS.calibration.http
})
```

#### Cleaning Up Connections

When using WebSocket connections, it's important to properly close them when your application is done:

```typescript
// Get the provider instance
const provider = synapse.getProvider()

// Clean up the connection
if (provider && typeof provider.destroy === 'function') {
  await provider.destroy()
}
```

This is especially important for:

- **CLI tools**: Ensures the process can exit cleanly
- **Test suites**: Prevents hanging tests and resource leaks
- **Server applications**: Frees resources when shutting down
- **Long-running applications**: Allows graceful reconnection if needed

#### Connection Best Practices

1. **Reuse connections**: Create a single Synapse instance and reuse it for multiple operations
2. **Handle disconnections**: Implement reconnection logic for long-running applications
3. **Clean up on exit**: Always destroy connections when your application terminates

```typescript
// Example: Proper cleanup in a Node.js application
process.on('SIGINT', async () => {
  console.log('Shutting down...')
  const provider = synapse.getProvider()
  if (provider && typeof provider.destroy === 'function') {
    await provider.destroy()
  }
  process.exit(0)
})
```

### Network Details

#### Filecoin Mainnet

- Chain ID: 314
- USDFC Contract: `0x80B98d3aa09ffff255c3ba4A241111Ff1262F045`

#### Filecoin Calibration Testnet

- Chain ID: 314159
- USDFC Contract: `0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0`

---
